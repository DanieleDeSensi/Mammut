// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: topology-remote.proto

#ifndef PROTOBUF_topology_2dremote_2eproto__INCLUDED
#define PROTOBUF_topology_2dremote_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mammut {
namespace topology {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_topology_2dremote_2eproto();
void protobuf_AssignDesc_topology_2dremote_2eproto();
void protobuf_ShutdownFile_topology_2dremote_2eproto();

class GetTopology;
class GetTopologyRes;
class GetTopologyRes_Vcc;
class GetCpuVendorId;
class GetCpuVendorIdRes;
class GetCpuFamily;
class GetCpuFamilyRes;
class GetCpuModel;
class GetCpuModelRes;

// ===================================================================

class GetTopology : public ::google::protobuf::MessageLite {
 public:
  GetTopology();
  virtual ~GetTopology();

  GetTopology(const GetTopology& from);

  inline GetTopology& operator=(const GetTopology& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTopology& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTopology* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTopology* other);

  // implements Message ----------------------------------------------

  GetTopology* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTopology& from);
  void MergeFrom(const GetTopology& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mammut.topology.GetTopology)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetTopology* default_instance_;
};
// -------------------------------------------------------------------

class GetTopologyRes_Vcc : public ::google::protobuf::MessageLite {
 public:
  GetTopologyRes_Vcc();
  virtual ~GetTopologyRes_Vcc();

  GetTopologyRes_Vcc(const GetTopologyRes_Vcc& from);

  inline GetTopologyRes_Vcc& operator=(const GetTopologyRes_Vcc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTopologyRes_Vcc& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTopologyRes_Vcc* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTopologyRes_Vcc* other);

  // implements Message ----------------------------------------------

  GetTopologyRes_Vcc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTopologyRes_Vcc& from);
  void MergeFrom(const GetTopologyRes_Vcc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cpu_id = 1;
  inline bool has_cpu_id() const;
  inline void clear_cpu_id();
  static const int kCpuIdFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_id() const;
  inline void set_cpu_id(::google::protobuf::uint32 value);

  // required uint32 physical_core_id = 2;
  inline bool has_physical_core_id() const;
  inline void clear_physical_core_id();
  static const int kPhysicalCoreIdFieldNumber = 2;
  inline ::google::protobuf::uint32 physical_core_id() const;
  inline void set_physical_core_id(::google::protobuf::uint32 value);

  // required uint32 virtual_core_id = 3;
  inline bool has_virtual_core_id() const;
  inline void clear_virtual_core_id();
  static const int kVirtualCoreIdFieldNumber = 3;
  inline ::google::protobuf::uint32 virtual_core_id() const;
  inline void set_virtual_core_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetTopologyRes.Vcc)
 private:
  inline void set_has_cpu_id();
  inline void clear_has_cpu_id();
  inline void set_has_physical_core_id();
  inline void clear_has_physical_core_id();
  inline void set_has_virtual_core_id();
  inline void clear_has_virtual_core_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 cpu_id_;
  ::google::protobuf::uint32 physical_core_id_;
  ::google::protobuf::uint32 virtual_core_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetTopologyRes_Vcc* default_instance_;
};
// -------------------------------------------------------------------

class GetTopologyRes : public ::google::protobuf::MessageLite {
 public:
  GetTopologyRes();
  virtual ~GetTopologyRes();

  GetTopologyRes(const GetTopologyRes& from);

  inline GetTopologyRes& operator=(const GetTopologyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetTopologyRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTopologyRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTopologyRes* other);

  // implements Message ----------------------------------------------

  GetTopologyRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTopologyRes& from);
  void MergeFrom(const GetTopologyRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetTopologyRes_Vcc Vcc;

  // accessors -------------------------------------------------------

  // repeated .mammut.topology.GetTopologyRes.Vcc coordinates = 1;
  inline int coordinates_size() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::mammut::topology::GetTopologyRes_Vcc& coordinates(int index) const;
  inline ::mammut::topology::GetTopologyRes_Vcc* mutable_coordinates(int index);
  inline ::mammut::topology::GetTopologyRes_Vcc* add_coordinates();
  inline const ::google::protobuf::RepeatedPtrField< ::mammut::topology::GetTopologyRes_Vcc >&
      coordinates() const;
  inline ::google::protobuf::RepeatedPtrField< ::mammut::topology::GetTopologyRes_Vcc >*
      mutable_coordinates();

  // @@protoc_insertion_point(class_scope:mammut.topology.GetTopologyRes)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mammut::topology::GetTopologyRes_Vcc > coordinates_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetTopologyRes* default_instance_;
};
// -------------------------------------------------------------------

class GetCpuVendorId : public ::google::protobuf::MessageLite {
 public:
  GetCpuVendorId();
  virtual ~GetCpuVendorId();

  GetCpuVendorId(const GetCpuVendorId& from);

  inline GetCpuVendorId& operator=(const GetCpuVendorId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCpuVendorId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCpuVendorId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCpuVendorId* other);

  // implements Message ----------------------------------------------

  GetCpuVendorId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCpuVendorId& from);
  void MergeFrom(const GetCpuVendorId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cpu_id = 1;
  inline bool has_cpu_id() const;
  inline void clear_cpu_id();
  static const int kCpuIdFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_id() const;
  inline void set_cpu_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetCpuVendorId)
 private:
  inline void set_has_cpu_id();
  inline void clear_has_cpu_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 cpu_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetCpuVendorId* default_instance_;
};
// -------------------------------------------------------------------

class GetCpuVendorIdRes : public ::google::protobuf::MessageLite {
 public:
  GetCpuVendorIdRes();
  virtual ~GetCpuVendorIdRes();

  GetCpuVendorIdRes(const GetCpuVendorIdRes& from);

  inline GetCpuVendorIdRes& operator=(const GetCpuVendorIdRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCpuVendorIdRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCpuVendorIdRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCpuVendorIdRes* other);

  // implements Message ----------------------------------------------

  GetCpuVendorIdRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCpuVendorIdRes& from);
  void MergeFrom(const GetCpuVendorIdRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string vendor_id = 1;
  inline bool has_vendor_id() const;
  inline void clear_vendor_id();
  static const int kVendorIdFieldNumber = 1;
  inline const ::std::string& vendor_id() const;
  inline void set_vendor_id(const ::std::string& value);
  inline void set_vendor_id(const char* value);
  inline void set_vendor_id(const char* value, size_t size);
  inline ::std::string* mutable_vendor_id();
  inline ::std::string* release_vendor_id();
  inline void set_allocated_vendor_id(::std::string* vendor_id);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetCpuVendorIdRes)
 private:
  inline void set_has_vendor_id();
  inline void clear_has_vendor_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* vendor_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetCpuVendorIdRes* default_instance_;
};
// -------------------------------------------------------------------

class GetCpuFamily : public ::google::protobuf::MessageLite {
 public:
  GetCpuFamily();
  virtual ~GetCpuFamily();

  GetCpuFamily(const GetCpuFamily& from);

  inline GetCpuFamily& operator=(const GetCpuFamily& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCpuFamily& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCpuFamily* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCpuFamily* other);

  // implements Message ----------------------------------------------

  GetCpuFamily* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCpuFamily& from);
  void MergeFrom(const GetCpuFamily& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cpu_id = 1;
  inline bool has_cpu_id() const;
  inline void clear_cpu_id();
  static const int kCpuIdFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_id() const;
  inline void set_cpu_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetCpuFamily)
 private:
  inline void set_has_cpu_id();
  inline void clear_has_cpu_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 cpu_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetCpuFamily* default_instance_;
};
// -------------------------------------------------------------------

class GetCpuFamilyRes : public ::google::protobuf::MessageLite {
 public:
  GetCpuFamilyRes();
  virtual ~GetCpuFamilyRes();

  GetCpuFamilyRes(const GetCpuFamilyRes& from);

  inline GetCpuFamilyRes& operator=(const GetCpuFamilyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCpuFamilyRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCpuFamilyRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCpuFamilyRes* other);

  // implements Message ----------------------------------------------

  GetCpuFamilyRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCpuFamilyRes& from);
  void MergeFrom(const GetCpuFamilyRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string family = 1;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 1;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const char* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetCpuFamilyRes)
 private:
  inline void set_has_family();
  inline void clear_has_family();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* family_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetCpuFamilyRes* default_instance_;
};
// -------------------------------------------------------------------

class GetCpuModel : public ::google::protobuf::MessageLite {
 public:
  GetCpuModel();
  virtual ~GetCpuModel();

  GetCpuModel(const GetCpuModel& from);

  inline GetCpuModel& operator=(const GetCpuModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCpuModel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCpuModel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCpuModel* other);

  // implements Message ----------------------------------------------

  GetCpuModel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCpuModel& from);
  void MergeFrom(const GetCpuModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cpu_id = 1;
  inline bool has_cpu_id() const;
  inline void clear_cpu_id();
  static const int kCpuIdFieldNumber = 1;
  inline ::google::protobuf::uint32 cpu_id() const;
  inline void set_cpu_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetCpuModel)
 private:
  inline void set_has_cpu_id();
  inline void clear_has_cpu_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 cpu_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetCpuModel* default_instance_;
};
// -------------------------------------------------------------------

class GetCpuModelRes : public ::google::protobuf::MessageLite {
 public:
  GetCpuModelRes();
  virtual ~GetCpuModelRes();

  GetCpuModelRes(const GetCpuModelRes& from);

  inline GetCpuModelRes& operator=(const GetCpuModelRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCpuModelRes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCpuModelRes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCpuModelRes* other);

  // implements Message ----------------------------------------------

  GetCpuModelRes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCpuModelRes& from);
  void MergeFrom(const GetCpuModelRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // @@protoc_insertion_point(class_scope:mammut.topology.GetCpuModelRes)
 private:
  inline void set_has_model();
  inline void clear_has_model();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* model_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_topology_2dremote_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_topology_2dremote_2eproto();
  #endif
  friend void protobuf_AssignDesc_topology_2dremote_2eproto();
  friend void protobuf_ShutdownFile_topology_2dremote_2eproto();

  void InitAsDefaultInstance();
  static GetCpuModelRes* default_instance_;
};
// ===================================================================


// ===================================================================

// GetTopology

// -------------------------------------------------------------------

// GetTopologyRes_Vcc

// required uint32 cpu_id = 1;
inline bool GetTopologyRes_Vcc::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTopologyRes_Vcc::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTopologyRes_Vcc::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTopologyRes_Vcc::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 GetTopologyRes_Vcc::cpu_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetTopologyRes.Vcc.cpu_id)
  return cpu_id_;
}
inline void GetTopologyRes_Vcc::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
  // @@protoc_insertion_point(field_set:mammut.topology.GetTopologyRes.Vcc.cpu_id)
}

// required uint32 physical_core_id = 2;
inline bool GetTopologyRes_Vcc::has_physical_core_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTopologyRes_Vcc::set_has_physical_core_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTopologyRes_Vcc::clear_has_physical_core_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTopologyRes_Vcc::clear_physical_core_id() {
  physical_core_id_ = 0u;
  clear_has_physical_core_id();
}
inline ::google::protobuf::uint32 GetTopologyRes_Vcc::physical_core_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetTopologyRes.Vcc.physical_core_id)
  return physical_core_id_;
}
inline void GetTopologyRes_Vcc::set_physical_core_id(::google::protobuf::uint32 value) {
  set_has_physical_core_id();
  physical_core_id_ = value;
  // @@protoc_insertion_point(field_set:mammut.topology.GetTopologyRes.Vcc.physical_core_id)
}

// required uint32 virtual_core_id = 3;
inline bool GetTopologyRes_Vcc::has_virtual_core_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTopologyRes_Vcc::set_has_virtual_core_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTopologyRes_Vcc::clear_has_virtual_core_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTopologyRes_Vcc::clear_virtual_core_id() {
  virtual_core_id_ = 0u;
  clear_has_virtual_core_id();
}
inline ::google::protobuf::uint32 GetTopologyRes_Vcc::virtual_core_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetTopologyRes.Vcc.virtual_core_id)
  return virtual_core_id_;
}
inline void GetTopologyRes_Vcc::set_virtual_core_id(::google::protobuf::uint32 value) {
  set_has_virtual_core_id();
  virtual_core_id_ = value;
  // @@protoc_insertion_point(field_set:mammut.topology.GetTopologyRes.Vcc.virtual_core_id)
}

// -------------------------------------------------------------------

// GetTopologyRes

// repeated .mammut.topology.GetTopologyRes.Vcc coordinates = 1;
inline int GetTopologyRes::coordinates_size() const {
  return coordinates_.size();
}
inline void GetTopologyRes::clear_coordinates() {
  coordinates_.Clear();
}
inline const ::mammut::topology::GetTopologyRes_Vcc& GetTopologyRes::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetTopologyRes.coordinates)
  return coordinates_.Get(index);
}
inline ::mammut::topology::GetTopologyRes_Vcc* GetTopologyRes::mutable_coordinates(int index) {
  // @@protoc_insertion_point(field_mutable:mammut.topology.GetTopologyRes.coordinates)
  return coordinates_.Mutable(index);
}
inline ::mammut::topology::GetTopologyRes_Vcc* GetTopologyRes::add_coordinates() {
  // @@protoc_insertion_point(field_add:mammut.topology.GetTopologyRes.coordinates)
  return coordinates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mammut::topology::GetTopologyRes_Vcc >&
GetTopologyRes::coordinates() const {
  // @@protoc_insertion_point(field_list:mammut.topology.GetTopologyRes.coordinates)
  return coordinates_;
}
inline ::google::protobuf::RepeatedPtrField< ::mammut::topology::GetTopologyRes_Vcc >*
GetTopologyRes::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:mammut.topology.GetTopologyRes.coordinates)
  return &coordinates_;
}

// -------------------------------------------------------------------

// GetCpuVendorId

// required uint32 cpu_id = 1;
inline bool GetCpuVendorId::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCpuVendorId::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCpuVendorId::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCpuVendorId::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 GetCpuVendorId::cpu_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetCpuVendorId.cpu_id)
  return cpu_id_;
}
inline void GetCpuVendorId::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
  // @@protoc_insertion_point(field_set:mammut.topology.GetCpuVendorId.cpu_id)
}

// -------------------------------------------------------------------

// GetCpuVendorIdRes

// required string vendor_id = 1;
inline bool GetCpuVendorIdRes::has_vendor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCpuVendorIdRes::set_has_vendor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCpuVendorIdRes::clear_has_vendor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCpuVendorIdRes::clear_vendor_id() {
  if (vendor_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_id_->clear();
  }
  clear_has_vendor_id();
}
inline const ::std::string& GetCpuVendorIdRes::vendor_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetCpuVendorIdRes.vendor_id)
  return *vendor_id_;
}
inline void GetCpuVendorIdRes::set_vendor_id(const ::std::string& value) {
  set_has_vendor_id();
  if (vendor_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_id_ = new ::std::string;
  }
  vendor_id_->assign(value);
  // @@protoc_insertion_point(field_set:mammut.topology.GetCpuVendorIdRes.vendor_id)
}
inline void GetCpuVendorIdRes::set_vendor_id(const char* value) {
  set_has_vendor_id();
  if (vendor_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_id_ = new ::std::string;
  }
  vendor_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mammut.topology.GetCpuVendorIdRes.vendor_id)
}
inline void GetCpuVendorIdRes::set_vendor_id(const char* value, size_t size) {
  set_has_vendor_id();
  if (vendor_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_id_ = new ::std::string;
  }
  vendor_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mammut.topology.GetCpuVendorIdRes.vendor_id)
}
inline ::std::string* GetCpuVendorIdRes::mutable_vendor_id() {
  set_has_vendor_id();
  if (vendor_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vendor_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mammut.topology.GetCpuVendorIdRes.vendor_id)
  return vendor_id_;
}
inline ::std::string* GetCpuVendorIdRes::release_vendor_id() {
  clear_has_vendor_id();
  if (vendor_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vendor_id_;
    vendor_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCpuVendorIdRes::set_allocated_vendor_id(::std::string* vendor_id) {
  if (vendor_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vendor_id_;
  }
  if (vendor_id) {
    set_has_vendor_id();
    vendor_id_ = vendor_id;
  } else {
    clear_has_vendor_id();
    vendor_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mammut.topology.GetCpuVendorIdRes.vendor_id)
}

// -------------------------------------------------------------------

// GetCpuFamily

// required uint32 cpu_id = 1;
inline bool GetCpuFamily::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCpuFamily::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCpuFamily::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCpuFamily::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 GetCpuFamily::cpu_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetCpuFamily.cpu_id)
  return cpu_id_;
}
inline void GetCpuFamily::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
  // @@protoc_insertion_point(field_set:mammut.topology.GetCpuFamily.cpu_id)
}

// -------------------------------------------------------------------

// GetCpuFamilyRes

// required string family = 1;
inline bool GetCpuFamilyRes::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCpuFamilyRes::set_has_family() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCpuFamilyRes::clear_has_family() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCpuFamilyRes::clear_family() {
  if (family_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& GetCpuFamilyRes::family() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetCpuFamilyRes.family)
  return *family_;
}
inline void GetCpuFamilyRes::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    family_ = new ::std::string;
  }
  family_->assign(value);
  // @@protoc_insertion_point(field_set:mammut.topology.GetCpuFamilyRes.family)
}
inline void GetCpuFamilyRes::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    family_ = new ::std::string;
  }
  family_->assign(value);
  // @@protoc_insertion_point(field_set_char:mammut.topology.GetCpuFamilyRes.family)
}
inline void GetCpuFamilyRes::set_family(const char* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mammut.topology.GetCpuFamilyRes.family)
}
inline ::std::string* GetCpuFamilyRes::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    family_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mammut.topology.GetCpuFamilyRes.family)
  return family_;
}
inline ::std::string* GetCpuFamilyRes::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCpuFamilyRes::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mammut.topology.GetCpuFamilyRes.family)
}

// -------------------------------------------------------------------

// GetCpuModel

// required uint32 cpu_id = 1;
inline bool GetCpuModel::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCpuModel::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCpuModel::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCpuModel::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 GetCpuModel::cpu_id() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetCpuModel.cpu_id)
  return cpu_id_;
}
inline void GetCpuModel::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
  // @@protoc_insertion_point(field_set:mammut.topology.GetCpuModel.cpu_id)
}

// -------------------------------------------------------------------

// GetCpuModelRes

// required string model = 1;
inline bool GetCpuModelRes::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCpuModelRes::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCpuModelRes::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCpuModelRes::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& GetCpuModelRes::model() const {
  // @@protoc_insertion_point(field_get:mammut.topology.GetCpuModelRes.model)
  return *model_;
}
inline void GetCpuModelRes::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:mammut.topology.GetCpuModelRes.model)
}
inline void GetCpuModelRes::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:mammut.topology.GetCpuModelRes.model)
}
inline void GetCpuModelRes::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mammut.topology.GetCpuModelRes.model)
}
inline ::std::string* GetCpuModelRes::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mammut.topology.GetCpuModelRes.model)
  return model_;
}
inline ::std::string* GetCpuModelRes::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetCpuModelRes::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mammut.topology.GetCpuModelRes.model)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace topology
}  // namespace mammut

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_topology_2dremote_2eproto__INCLUDED
