// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cpufreq-remote.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cpufreq-remote.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace mammut {
namespace cpufreq {

void protobuf_ShutdownFile_cpufreq_2dremote_2eproto() {
  delete GetDomains::default_instance_;
  delete GetDomainsRes::default_instance_;
  delete GetDomainsRes_Domain::default_instance_;
  delete GetAvailableFrequencies::default_instance_;
  delete GetAvailableFrequenciesRes::default_instance_;
  delete GetAvailableGovernors::default_instance_;
  delete GetAvailableGovernorsRes::default_instance_;
  delete GetCurrentFrequency::default_instance_;
  delete GetCurrentFrequencyRes::default_instance_;
  delete GetCurrentGovernor::default_instance_;
  delete GetCurrentGovernorRes::default_instance_;
  delete ChangeFrequency::default_instance_;
  delete ChangeFrequencyBounds::default_instance_;
  delete ChangeGovernor::default_instance_;
  delete Result::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_cpufreq_2dremote_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_cpufreq_2dremote_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  GetDomains::default_instance_ = new GetDomains();
  GetDomainsRes::default_instance_ = new GetDomainsRes();
  GetDomainsRes_Domain::default_instance_ = new GetDomainsRes_Domain();
  GetAvailableFrequencies::default_instance_ = new GetAvailableFrequencies();
  GetAvailableFrequenciesRes::default_instance_ = new GetAvailableFrequenciesRes();
  GetAvailableGovernors::default_instance_ = new GetAvailableGovernors();
  GetAvailableGovernorsRes::default_instance_ = new GetAvailableGovernorsRes();
  GetCurrentFrequency::default_instance_ = new GetCurrentFrequency();
  GetCurrentFrequencyRes::default_instance_ = new GetCurrentFrequencyRes();
  GetCurrentGovernor::default_instance_ = new GetCurrentGovernor();
  GetCurrentGovernorRes::default_instance_ = new GetCurrentGovernorRes();
  ChangeFrequency::default_instance_ = new ChangeFrequency();
  ChangeFrequencyBounds::default_instance_ = new ChangeFrequencyBounds();
  ChangeGovernor::default_instance_ = new ChangeGovernor();
  Result::default_instance_ = new Result();
  GetDomains::default_instance_->InitAsDefaultInstance();
  GetDomainsRes::default_instance_->InitAsDefaultInstance();
  GetDomainsRes_Domain::default_instance_->InitAsDefaultInstance();
  GetAvailableFrequencies::default_instance_->InitAsDefaultInstance();
  GetAvailableFrequenciesRes::default_instance_->InitAsDefaultInstance();
  GetAvailableGovernors::default_instance_->InitAsDefaultInstance();
  GetAvailableGovernorsRes::default_instance_->InitAsDefaultInstance();
  GetCurrentFrequency::default_instance_->InitAsDefaultInstance();
  GetCurrentFrequencyRes::default_instance_->InitAsDefaultInstance();
  GetCurrentGovernor::default_instance_->InitAsDefaultInstance();
  GetCurrentGovernorRes::default_instance_->InitAsDefaultInstance();
  ChangeFrequency::default_instance_->InitAsDefaultInstance();
  ChangeFrequencyBounds::default_instance_->InitAsDefaultInstance();
  ChangeGovernor::default_instance_->InitAsDefaultInstance();
  Result::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cpufreq_2dremote_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_cpufreq_2dremote_2eproto_once_);
void protobuf_AddDesc_cpufreq_2dremote_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_cpufreq_2dremote_2eproto_once_,
                 &protobuf_AddDesc_cpufreq_2dremote_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cpufreq_2dremote_2eproto {
  StaticDescriptorInitializer_cpufreq_2dremote_2eproto() {
    protobuf_AddDesc_cpufreq_2dremote_2eproto();
  }
} static_descriptor_initializer_cpufreq_2dremote_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetDomains::GetDomains()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetDomains)
}

void GetDomains::InitAsDefaultInstance() {
}

GetDomains::GetDomains(const GetDomains& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetDomains)
}

void GetDomains::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetDomains::~GetDomains() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetDomains)
  SharedDtor();
}

void GetDomains::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetDomains::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetDomains& GetDomains::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetDomains* GetDomains::default_instance_ = NULL;

GetDomains* GetDomains::New() const {
  return new GetDomains;
}

void GetDomains::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetDomains::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetDomains)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetDomains)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetDomains)
  return false;
#undef DO_
}

void GetDomains::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetDomains)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetDomains)
}

int GetDomains::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetDomains::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetDomains*>(&from));
}

void GetDomains::MergeFrom(const GetDomains& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetDomains::CopyFrom(const GetDomains& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetDomains::IsInitialized() const {

  return true;
}

void GetDomains::Swap(GetDomains* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetDomains::GetTypeName() const {
  return "mammut.cpufreq.GetDomains";
}


// ===================================================================

#ifndef _MSC_VER
const int GetDomainsRes_Domain::kIdFieldNumber;
const int GetDomainsRes_Domain::kVirtualCoresIdsFieldNumber;
#endif  // !_MSC_VER

GetDomainsRes_Domain::GetDomainsRes_Domain()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetDomainsRes.Domain)
}

void GetDomainsRes_Domain::InitAsDefaultInstance() {
}

GetDomainsRes_Domain::GetDomainsRes_Domain(const GetDomainsRes_Domain& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetDomainsRes.Domain)
}

void GetDomainsRes_Domain::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetDomainsRes_Domain::~GetDomainsRes_Domain() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetDomainsRes.Domain)
  SharedDtor();
}

void GetDomainsRes_Domain::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetDomainsRes_Domain::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetDomainsRes_Domain& GetDomainsRes_Domain::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetDomainsRes_Domain* GetDomainsRes_Domain::default_instance_ = NULL;

GetDomainsRes_Domain* GetDomainsRes_Domain::New() const {
  return new GetDomainsRes_Domain;
}

void GetDomainsRes_Domain::Clear() {
  id_ = 0u;
  virtual_cores_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetDomainsRes_Domain::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetDomainsRes.Domain)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_virtual_cores_ids;
        break;
      }

      // repeated uint32 virtual_cores_ids = 2 [packed = true];
      case 2: {
        if (tag == 18) {
         parse_virtual_cores_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_virtual_cores_ids())));
        } else if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 18, input, this->mutable_virtual_cores_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetDomainsRes.Domain)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetDomainsRes.Domain)
  return false;
#undef DO_
}

void GetDomainsRes_Domain::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetDomainsRes.Domain)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // repeated uint32 virtual_cores_ids = 2 [packed = true];
  if (this->virtual_cores_ids_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_virtual_cores_ids_cached_byte_size_);
  }
  for (int i = 0; i < this->virtual_cores_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->virtual_cores_ids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetDomainsRes.Domain)
}

int GetDomainsRes_Domain::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  // repeated uint32 virtual_cores_ids = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->virtual_cores_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->virtual_cores_ids(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _virtual_cores_ids_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetDomainsRes_Domain::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetDomainsRes_Domain*>(&from));
}

void GetDomainsRes_Domain::MergeFrom(const GetDomainsRes_Domain& from) {
  GOOGLE_CHECK_NE(&from, this);
  virtual_cores_ids_.MergeFrom(from.virtual_cores_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetDomainsRes_Domain::CopyFrom(const GetDomainsRes_Domain& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetDomainsRes_Domain::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetDomainsRes_Domain::Swap(GetDomainsRes_Domain* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    virtual_cores_ids_.Swap(&other->virtual_cores_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetDomainsRes_Domain::GetTypeName() const {
  return "mammut.cpufreq.GetDomainsRes.Domain";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetDomainsRes::kDomainsFieldNumber;
#endif  // !_MSC_VER

GetDomainsRes::GetDomainsRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetDomainsRes)
}

void GetDomainsRes::InitAsDefaultInstance() {
}

GetDomainsRes::GetDomainsRes(const GetDomainsRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetDomainsRes)
}

void GetDomainsRes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetDomainsRes::~GetDomainsRes() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetDomainsRes)
  SharedDtor();
}

void GetDomainsRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetDomainsRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetDomainsRes& GetDomainsRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetDomainsRes* GetDomainsRes::default_instance_ = NULL;

GetDomainsRes* GetDomainsRes::New() const {
  return new GetDomainsRes;
}

void GetDomainsRes::Clear() {
  domains_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetDomainsRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetDomainsRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mammut.cpufreq.GetDomainsRes.Domain domains = 1;
      case 1: {
        if (tag == 10) {
         parse_domains:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_domains()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_domains;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetDomainsRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetDomainsRes)
  return false;
#undef DO_
}

void GetDomainsRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetDomainsRes)
  // repeated .mammut.cpufreq.GetDomainsRes.Domain domains = 1;
  for (int i = 0; i < this->domains_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->domains(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetDomainsRes)
}

int GetDomainsRes::ByteSize() const {
  int total_size = 0;

  // repeated .mammut.cpufreq.GetDomainsRes.Domain domains = 1;
  total_size += 1 * this->domains_size();
  for (int i = 0; i < this->domains_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->domains(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetDomainsRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetDomainsRes*>(&from));
}

void GetDomainsRes::MergeFrom(const GetDomainsRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  domains_.MergeFrom(from.domains_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetDomainsRes::CopyFrom(const GetDomainsRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetDomainsRes::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->domains())) return false;
  return true;
}

void GetDomainsRes::Swap(GetDomainsRes* other) {
  if (other != this) {
    domains_.Swap(&other->domains_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetDomainsRes::GetTypeName() const {
  return "mammut.cpufreq.GetDomainsRes";
}


// ===================================================================

#ifndef _MSC_VER
const int GetAvailableFrequencies::kIdFieldNumber;
#endif  // !_MSC_VER

GetAvailableFrequencies::GetAvailableFrequencies()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetAvailableFrequencies)
}

void GetAvailableFrequencies::InitAsDefaultInstance() {
}

GetAvailableFrequencies::GetAvailableFrequencies(const GetAvailableFrequencies& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetAvailableFrequencies)
}

void GetAvailableFrequencies::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAvailableFrequencies::~GetAvailableFrequencies() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetAvailableFrequencies)
  SharedDtor();
}

void GetAvailableFrequencies::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAvailableFrequencies::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAvailableFrequencies& GetAvailableFrequencies::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetAvailableFrequencies* GetAvailableFrequencies::default_instance_ = NULL;

GetAvailableFrequencies* GetAvailableFrequencies::New() const {
  return new GetAvailableFrequencies;
}

void GetAvailableFrequencies::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetAvailableFrequencies::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetAvailableFrequencies)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetAvailableFrequencies)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetAvailableFrequencies)
  return false;
#undef DO_
}

void GetAvailableFrequencies::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetAvailableFrequencies)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetAvailableFrequencies)
}

int GetAvailableFrequencies::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAvailableFrequencies::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAvailableFrequencies*>(&from));
}

void GetAvailableFrequencies::MergeFrom(const GetAvailableFrequencies& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetAvailableFrequencies::CopyFrom(const GetAvailableFrequencies& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAvailableFrequencies::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetAvailableFrequencies::Swap(GetAvailableFrequencies* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetAvailableFrequencies::GetTypeName() const {
  return "mammut.cpufreq.GetAvailableFrequencies";
}


// ===================================================================

#ifndef _MSC_VER
const int GetAvailableFrequenciesRes::kFrequenciesFieldNumber;
#endif  // !_MSC_VER

GetAvailableFrequenciesRes::GetAvailableFrequenciesRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetAvailableFrequenciesRes)
}

void GetAvailableFrequenciesRes::InitAsDefaultInstance() {
}

GetAvailableFrequenciesRes::GetAvailableFrequenciesRes(const GetAvailableFrequenciesRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetAvailableFrequenciesRes)
}

void GetAvailableFrequenciesRes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAvailableFrequenciesRes::~GetAvailableFrequenciesRes() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetAvailableFrequenciesRes)
  SharedDtor();
}

void GetAvailableFrequenciesRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAvailableFrequenciesRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAvailableFrequenciesRes& GetAvailableFrequenciesRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetAvailableFrequenciesRes* GetAvailableFrequenciesRes::default_instance_ = NULL;

GetAvailableFrequenciesRes* GetAvailableFrequenciesRes::New() const {
  return new GetAvailableFrequenciesRes;
}

void GetAvailableFrequenciesRes::Clear() {
  frequencies_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetAvailableFrequenciesRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetAvailableFrequenciesRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 frequencies = 1 [packed = true];
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_frequencies())));
        } else if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_frequencies())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetAvailableFrequenciesRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetAvailableFrequenciesRes)
  return false;
#undef DO_
}

void GetAvailableFrequenciesRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetAvailableFrequenciesRes)
  // repeated uint32 frequencies = 1 [packed = true];
  if (this->frequencies_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_frequencies_cached_byte_size_);
  }
  for (int i = 0; i < this->frequencies_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->frequencies(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetAvailableFrequenciesRes)
}

int GetAvailableFrequenciesRes::ByteSize() const {
  int total_size = 0;

  // repeated uint32 frequencies = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->frequencies_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->frequencies(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _frequencies_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAvailableFrequenciesRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAvailableFrequenciesRes*>(&from));
}

void GetAvailableFrequenciesRes::MergeFrom(const GetAvailableFrequenciesRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  frequencies_.MergeFrom(from.frequencies_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetAvailableFrequenciesRes::CopyFrom(const GetAvailableFrequenciesRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAvailableFrequenciesRes::IsInitialized() const {

  return true;
}

void GetAvailableFrequenciesRes::Swap(GetAvailableFrequenciesRes* other) {
  if (other != this) {
    frequencies_.Swap(&other->frequencies_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetAvailableFrequenciesRes::GetTypeName() const {
  return "mammut.cpufreq.GetAvailableFrequenciesRes";
}


// ===================================================================

#ifndef _MSC_VER
const int GetAvailableGovernors::kIdFieldNumber;
#endif  // !_MSC_VER

GetAvailableGovernors::GetAvailableGovernors()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetAvailableGovernors)
}

void GetAvailableGovernors::InitAsDefaultInstance() {
}

GetAvailableGovernors::GetAvailableGovernors(const GetAvailableGovernors& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetAvailableGovernors)
}

void GetAvailableGovernors::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAvailableGovernors::~GetAvailableGovernors() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetAvailableGovernors)
  SharedDtor();
}

void GetAvailableGovernors::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAvailableGovernors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAvailableGovernors& GetAvailableGovernors::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetAvailableGovernors* GetAvailableGovernors::default_instance_ = NULL;

GetAvailableGovernors* GetAvailableGovernors::New() const {
  return new GetAvailableGovernors;
}

void GetAvailableGovernors::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetAvailableGovernors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetAvailableGovernors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetAvailableGovernors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetAvailableGovernors)
  return false;
#undef DO_
}

void GetAvailableGovernors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetAvailableGovernors)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetAvailableGovernors)
}

int GetAvailableGovernors::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAvailableGovernors::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAvailableGovernors*>(&from));
}

void GetAvailableGovernors::MergeFrom(const GetAvailableGovernors& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetAvailableGovernors::CopyFrom(const GetAvailableGovernors& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAvailableGovernors::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetAvailableGovernors::Swap(GetAvailableGovernors* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetAvailableGovernors::GetTypeName() const {
  return "mammut.cpufreq.GetAvailableGovernors";
}


// ===================================================================

#ifndef _MSC_VER
const int GetAvailableGovernorsRes::kGovernorsFieldNumber;
#endif  // !_MSC_VER

GetAvailableGovernorsRes::GetAvailableGovernorsRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetAvailableGovernorsRes)
}

void GetAvailableGovernorsRes::InitAsDefaultInstance() {
}

GetAvailableGovernorsRes::GetAvailableGovernorsRes(const GetAvailableGovernorsRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetAvailableGovernorsRes)
}

void GetAvailableGovernorsRes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAvailableGovernorsRes::~GetAvailableGovernorsRes() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetAvailableGovernorsRes)
  SharedDtor();
}

void GetAvailableGovernorsRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAvailableGovernorsRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAvailableGovernorsRes& GetAvailableGovernorsRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetAvailableGovernorsRes* GetAvailableGovernorsRes::default_instance_ = NULL;

GetAvailableGovernorsRes* GetAvailableGovernorsRes::New() const {
  return new GetAvailableGovernorsRes;
}

void GetAvailableGovernorsRes::Clear() {
  governors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetAvailableGovernorsRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetAvailableGovernorsRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 governors = 1 [packed = true];
      case 1: {
        if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_governors())));
        } else if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_governors())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetAvailableGovernorsRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetAvailableGovernorsRes)
  return false;
#undef DO_
}

void GetAvailableGovernorsRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetAvailableGovernorsRes)
  // repeated uint32 governors = 1 [packed = true];
  if (this->governors_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_governors_cached_byte_size_);
  }
  for (int i = 0; i < this->governors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->governors(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetAvailableGovernorsRes)
}

int GetAvailableGovernorsRes::ByteSize() const {
  int total_size = 0;

  // repeated uint32 governors = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->governors_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->governors(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _governors_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAvailableGovernorsRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAvailableGovernorsRes*>(&from));
}

void GetAvailableGovernorsRes::MergeFrom(const GetAvailableGovernorsRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  governors_.MergeFrom(from.governors_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetAvailableGovernorsRes::CopyFrom(const GetAvailableGovernorsRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAvailableGovernorsRes::IsInitialized() const {

  return true;
}

void GetAvailableGovernorsRes::Swap(GetAvailableGovernorsRes* other) {
  if (other != this) {
    governors_.Swap(&other->governors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetAvailableGovernorsRes::GetTypeName() const {
  return "mammut.cpufreq.GetAvailableGovernorsRes";
}


// ===================================================================

#ifndef _MSC_VER
const int GetCurrentFrequency::kIdFieldNumber;
const int GetCurrentFrequency::kUserspaceFieldNumber;
#endif  // !_MSC_VER

GetCurrentFrequency::GetCurrentFrequency()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetCurrentFrequency)
}

void GetCurrentFrequency::InitAsDefaultInstance() {
}

GetCurrentFrequency::GetCurrentFrequency(const GetCurrentFrequency& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetCurrentFrequency)
}

void GetCurrentFrequency::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  userspace_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCurrentFrequency::~GetCurrentFrequency() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetCurrentFrequency)
  SharedDtor();
}

void GetCurrentFrequency::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetCurrentFrequency::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCurrentFrequency& GetCurrentFrequency::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetCurrentFrequency* GetCurrentFrequency::default_instance_ = NULL;

GetCurrentFrequency* GetCurrentFrequency::New() const {
  return new GetCurrentFrequency;
}

void GetCurrentFrequency::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GetCurrentFrequency*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, userspace_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetCurrentFrequency::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetCurrentFrequency)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_userspace;
        break;
      }

      // required bool userspace = 2;
      case 2: {
        if (tag == 16) {
         parse_userspace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &userspace_)));
          set_has_userspace();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetCurrentFrequency)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetCurrentFrequency)
  return false;
#undef DO_
}

void GetCurrentFrequency::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetCurrentFrequency)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required bool userspace = 2;
  if (has_userspace()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->userspace(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetCurrentFrequency)
}

int GetCurrentFrequency::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required bool userspace = 2;
    if (has_userspace()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCurrentFrequency::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCurrentFrequency*>(&from));
}

void GetCurrentFrequency::MergeFrom(const GetCurrentFrequency& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_userspace()) {
      set_userspace(from.userspace());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetCurrentFrequency::CopyFrom(const GetCurrentFrequency& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCurrentFrequency::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GetCurrentFrequency::Swap(GetCurrentFrequency* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(userspace_, other->userspace_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCurrentFrequency::GetTypeName() const {
  return "mammut.cpufreq.GetCurrentFrequency";
}


// ===================================================================

#ifndef _MSC_VER
const int GetCurrentFrequencyRes::kFrequencyFieldNumber;
#endif  // !_MSC_VER

GetCurrentFrequencyRes::GetCurrentFrequencyRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetCurrentFrequencyRes)
}

void GetCurrentFrequencyRes::InitAsDefaultInstance() {
}

GetCurrentFrequencyRes::GetCurrentFrequencyRes(const GetCurrentFrequencyRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetCurrentFrequencyRes)
}

void GetCurrentFrequencyRes::SharedCtor() {
  _cached_size_ = 0;
  frequency_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCurrentFrequencyRes::~GetCurrentFrequencyRes() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetCurrentFrequencyRes)
  SharedDtor();
}

void GetCurrentFrequencyRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetCurrentFrequencyRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCurrentFrequencyRes& GetCurrentFrequencyRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetCurrentFrequencyRes* GetCurrentFrequencyRes::default_instance_ = NULL;

GetCurrentFrequencyRes* GetCurrentFrequencyRes::New() const {
  return new GetCurrentFrequencyRes;
}

void GetCurrentFrequencyRes::Clear() {
  frequency_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetCurrentFrequencyRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetCurrentFrequencyRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 frequency = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frequency_)));
          set_has_frequency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetCurrentFrequencyRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetCurrentFrequencyRes)
  return false;
#undef DO_
}

void GetCurrentFrequencyRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetCurrentFrequencyRes)
  // required uint32 frequency = 1;
  if (has_frequency()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->frequency(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetCurrentFrequencyRes)
}

int GetCurrentFrequencyRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 frequency = 1;
    if (has_frequency()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frequency());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCurrentFrequencyRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCurrentFrequencyRes*>(&from));
}

void GetCurrentFrequencyRes::MergeFrom(const GetCurrentFrequencyRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frequency()) {
      set_frequency(from.frequency());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetCurrentFrequencyRes::CopyFrom(const GetCurrentFrequencyRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCurrentFrequencyRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetCurrentFrequencyRes::Swap(GetCurrentFrequencyRes* other) {
  if (other != this) {
    std::swap(frequency_, other->frequency_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCurrentFrequencyRes::GetTypeName() const {
  return "mammut.cpufreq.GetCurrentFrequencyRes";
}


// ===================================================================

#ifndef _MSC_VER
const int GetCurrentGovernor::kIdFieldNumber;
#endif  // !_MSC_VER

GetCurrentGovernor::GetCurrentGovernor()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetCurrentGovernor)
}

void GetCurrentGovernor::InitAsDefaultInstance() {
}

GetCurrentGovernor::GetCurrentGovernor(const GetCurrentGovernor& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetCurrentGovernor)
}

void GetCurrentGovernor::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCurrentGovernor::~GetCurrentGovernor() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetCurrentGovernor)
  SharedDtor();
}

void GetCurrentGovernor::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetCurrentGovernor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCurrentGovernor& GetCurrentGovernor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetCurrentGovernor* GetCurrentGovernor::default_instance_ = NULL;

GetCurrentGovernor* GetCurrentGovernor::New() const {
  return new GetCurrentGovernor;
}

void GetCurrentGovernor::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetCurrentGovernor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetCurrentGovernor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetCurrentGovernor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetCurrentGovernor)
  return false;
#undef DO_
}

void GetCurrentGovernor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetCurrentGovernor)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetCurrentGovernor)
}

int GetCurrentGovernor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCurrentGovernor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCurrentGovernor*>(&from));
}

void GetCurrentGovernor::MergeFrom(const GetCurrentGovernor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetCurrentGovernor::CopyFrom(const GetCurrentGovernor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCurrentGovernor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetCurrentGovernor::Swap(GetCurrentGovernor* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCurrentGovernor::GetTypeName() const {
  return "mammut.cpufreq.GetCurrentGovernor";
}


// ===================================================================

#ifndef _MSC_VER
const int GetCurrentGovernorRes::kGovernorFieldNumber;
#endif  // !_MSC_VER

GetCurrentGovernorRes::GetCurrentGovernorRes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.GetCurrentGovernorRes)
}

void GetCurrentGovernorRes::InitAsDefaultInstance() {
}

GetCurrentGovernorRes::GetCurrentGovernorRes(const GetCurrentGovernorRes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.GetCurrentGovernorRes)
}

void GetCurrentGovernorRes::SharedCtor() {
  _cached_size_ = 0;
  governor_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCurrentGovernorRes::~GetCurrentGovernorRes() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.GetCurrentGovernorRes)
  SharedDtor();
}

void GetCurrentGovernorRes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetCurrentGovernorRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCurrentGovernorRes& GetCurrentGovernorRes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

GetCurrentGovernorRes* GetCurrentGovernorRes::default_instance_ = NULL;

GetCurrentGovernorRes* GetCurrentGovernorRes::New() const {
  return new GetCurrentGovernorRes;
}

void GetCurrentGovernorRes::Clear() {
  governor_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetCurrentGovernorRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.GetCurrentGovernorRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 governor = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &governor_)));
          set_has_governor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.GetCurrentGovernorRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.GetCurrentGovernorRes)
  return false;
#undef DO_
}

void GetCurrentGovernorRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.GetCurrentGovernorRes)
  // required uint32 governor = 1;
  if (has_governor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->governor(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.GetCurrentGovernorRes)
}

int GetCurrentGovernorRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 governor = 1;
    if (has_governor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->governor());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCurrentGovernorRes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCurrentGovernorRes*>(&from));
}

void GetCurrentGovernorRes::MergeFrom(const GetCurrentGovernorRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_governor()) {
      set_governor(from.governor());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetCurrentGovernorRes::CopyFrom(const GetCurrentGovernorRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCurrentGovernorRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetCurrentGovernorRes::Swap(GetCurrentGovernorRes* other) {
  if (other != this) {
    std::swap(governor_, other->governor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCurrentGovernorRes::GetTypeName() const {
  return "mammut.cpufreq.GetCurrentGovernorRes";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeFrequency::kIdFieldNumber;
const int ChangeFrequency::kFrequencyFieldNumber;
#endif  // !_MSC_VER

ChangeFrequency::ChangeFrequency()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.ChangeFrequency)
}

void ChangeFrequency::InitAsDefaultInstance() {
}

ChangeFrequency::ChangeFrequency(const ChangeFrequency& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.ChangeFrequency)
}

void ChangeFrequency::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  frequency_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeFrequency::~ChangeFrequency() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.ChangeFrequency)
  SharedDtor();
}

void ChangeFrequency::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeFrequency::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeFrequency& ChangeFrequency::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

ChangeFrequency* ChangeFrequency::default_instance_ = NULL;

ChangeFrequency* ChangeFrequency::New() const {
  return new ChangeFrequency;
}

void ChangeFrequency::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ChangeFrequency*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, frequency_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChangeFrequency::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.ChangeFrequency)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_frequency;
        break;
      }

      // required uint32 frequency = 2;
      case 2: {
        if (tag == 16) {
         parse_frequency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frequency_)));
          set_has_frequency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.ChangeFrequency)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.ChangeFrequency)
  return false;
#undef DO_
}

void ChangeFrequency::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.ChangeFrequency)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 frequency = 2;
  if (has_frequency()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->frequency(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.ChangeFrequency)
}

int ChangeFrequency::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 frequency = 2;
    if (has_frequency()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frequency());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeFrequency::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeFrequency*>(&from));
}

void ChangeFrequency::MergeFrom(const ChangeFrequency& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_frequency()) {
      set_frequency(from.frequency());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChangeFrequency::CopyFrom(const ChangeFrequency& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeFrequency::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChangeFrequency::Swap(ChangeFrequency* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(frequency_, other->frequency_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeFrequency::GetTypeName() const {
  return "mammut.cpufreq.ChangeFrequency";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeFrequencyBounds::kIdFieldNumber;
const int ChangeFrequencyBounds::kLowerBoundFieldNumber;
const int ChangeFrequencyBounds::kUpperBoundFieldNumber;
#endif  // !_MSC_VER

ChangeFrequencyBounds::ChangeFrequencyBounds()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.ChangeFrequencyBounds)
}

void ChangeFrequencyBounds::InitAsDefaultInstance() {
}

ChangeFrequencyBounds::ChangeFrequencyBounds(const ChangeFrequencyBounds& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.ChangeFrequencyBounds)
}

void ChangeFrequencyBounds::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  lower_bound_ = 0u;
  upper_bound_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeFrequencyBounds::~ChangeFrequencyBounds() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.ChangeFrequencyBounds)
  SharedDtor();
}

void ChangeFrequencyBounds::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeFrequencyBounds::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeFrequencyBounds& ChangeFrequencyBounds::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

ChangeFrequencyBounds* ChangeFrequencyBounds::default_instance_ = NULL;

ChangeFrequencyBounds* ChangeFrequencyBounds::New() const {
  return new ChangeFrequencyBounds;
}

void ChangeFrequencyBounds::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ChangeFrequencyBounds*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, upper_bound_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChangeFrequencyBounds::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.ChangeFrequencyBounds)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_lower_bound;
        break;
      }

      // required uint32 lower_bound = 2;
      case 2: {
        if (tag == 16) {
         parse_lower_bound:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lower_bound_)));
          set_has_lower_bound();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_upper_bound;
        break;
      }

      // required uint32 upper_bound = 3;
      case 3: {
        if (tag == 24) {
         parse_upper_bound:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upper_bound_)));
          set_has_upper_bound();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.ChangeFrequencyBounds)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.ChangeFrequencyBounds)
  return false;
#undef DO_
}

void ChangeFrequencyBounds::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.ChangeFrequencyBounds)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 lower_bound = 2;
  if (has_lower_bound()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->lower_bound(), output);
  }

  // required uint32 upper_bound = 3;
  if (has_upper_bound()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->upper_bound(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.ChangeFrequencyBounds)
}

int ChangeFrequencyBounds::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 lower_bound = 2;
    if (has_lower_bound()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lower_bound());
    }

    // required uint32 upper_bound = 3;
    if (has_upper_bound()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upper_bound());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeFrequencyBounds::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeFrequencyBounds*>(&from));
}

void ChangeFrequencyBounds::MergeFrom(const ChangeFrequencyBounds& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_lower_bound()) {
      set_lower_bound(from.lower_bound());
    }
    if (from.has_upper_bound()) {
      set_upper_bound(from.upper_bound());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChangeFrequencyBounds::CopyFrom(const ChangeFrequencyBounds& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeFrequencyBounds::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ChangeFrequencyBounds::Swap(ChangeFrequencyBounds* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(lower_bound_, other->lower_bound_);
    std::swap(upper_bound_, other->upper_bound_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeFrequencyBounds::GetTypeName() const {
  return "mammut.cpufreq.ChangeFrequencyBounds";
}


// ===================================================================

#ifndef _MSC_VER
const int ChangeGovernor::kIdFieldNumber;
const int ChangeGovernor::kGovernorFieldNumber;
#endif  // !_MSC_VER

ChangeGovernor::ChangeGovernor()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.ChangeGovernor)
}

void ChangeGovernor::InitAsDefaultInstance() {
}

ChangeGovernor::ChangeGovernor(const ChangeGovernor& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.ChangeGovernor)
}

void ChangeGovernor::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  governor_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeGovernor::~ChangeGovernor() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.ChangeGovernor)
  SharedDtor();
}

void ChangeGovernor::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeGovernor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeGovernor& ChangeGovernor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

ChangeGovernor* ChangeGovernor::default_instance_ = NULL;

ChangeGovernor* ChangeGovernor::New() const {
  return new ChangeGovernor;
}

void ChangeGovernor::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ChangeGovernor*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, governor_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChangeGovernor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.ChangeGovernor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_governor;
        break;
      }

      // required uint32 governor = 2;
      case 2: {
        if (tag == 16) {
         parse_governor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &governor_)));
          set_has_governor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.ChangeGovernor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.ChangeGovernor)
  return false;
#undef DO_
}

void ChangeGovernor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.ChangeGovernor)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 governor = 2;
  if (has_governor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->governor(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.ChangeGovernor)
}

int ChangeGovernor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 governor = 2;
    if (has_governor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->governor());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeGovernor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeGovernor*>(&from));
}

void ChangeGovernor::MergeFrom(const ChangeGovernor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_governor()) {
      set_governor(from.governor());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChangeGovernor::CopyFrom(const ChangeGovernor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeGovernor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChangeGovernor::Swap(ChangeGovernor* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(governor_, other->governor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChangeGovernor::GetTypeName() const {
  return "mammut.cpufreq.ChangeGovernor";
}


// ===================================================================

#ifndef _MSC_VER
const int Result::kResultFieldNumber;
#endif  // !_MSC_VER

Result::Result()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mammut.cpufreq.Result)
}

void Result::InitAsDefaultInstance() {
}

Result::Result(const Result& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mammut.cpufreq.Result)
}

void Result::SharedCtor() {
  _cached_size_ = 0;
  result_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Result::~Result() {
  // @@protoc_insertion_point(destructor:mammut.cpufreq.Result)
  SharedDtor();
}

void Result::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Result::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Result& Result::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cpufreq_2dremote_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cpufreq_2dremote_2eproto();
#endif
  return *default_instance_;
}

Result* Result::default_instance_ = NULL;

Result* Result::New() const {
  return new Result;
}

void Result::Clear() {
  result_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Result::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:mammut.cpufreq.Result)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool result = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mammut.cpufreq.Result)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mammut.cpufreq.Result)
  return false;
#undef DO_
}

void Result::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mammut.cpufreq.Result)
  // required bool result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->result(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:mammut.cpufreq.Result)
}

int Result::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool result = 1;
    if (has_result()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Result::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Result*>(&from));
}

void Result::MergeFrom(const Result& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Result::CopyFrom(const Result& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Result::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Result::Swap(Result* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Result::GetTypeName() const {
  return "mammut.cpufreq.Result";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cpufreq
}  // namespace mammut

// @@protoc_insertion_point(global_scope)
