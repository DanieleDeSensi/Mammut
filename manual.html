<!DOCTYPE html>
<html lang="en">
	<head>
	    <meta charset="utf-8">
	    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	    <meta name="viewport" content="width=device-width, initial-scale=1">
	    <meta name="description" content="">
	    <meta name="author" content="">
	
	    <title>Mammut</title>
	    
	    <!-- Bootstrap Core CSS - Uses Bootswatch Flatly Theme: http://bootswatch.com/flatly/ -->
	    <link href="css/bootstrap.min.css" rel="stylesheet">
	    
	
	    <!-- Custom CSS -->
	    <link href="css/freelancer.css" rel="stylesheet">
	    <link href="css/barstyles.css" rel="stylesheet">
	    
	    <script src="js/prettify.js"></script>
	    <link href="css/prettifydesert.css" rel="stylesheet">
	    
	    <!-- Custom Fonts -->
	    <link href="font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
	    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css">
	    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
	
	    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
	    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
	    <!--[if lt IE 9]>
	        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
	        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
	    <![endif]-->
	    
	    <style>
			*[id]:before { 
				display: block; 
				content: " "; 
				margin-top: -120px; 
				height: 120px; 
				visibility: hidden; 
			}
			
			ul li{
 				font-size:18px;
			}
	    </style>

	</head>
	<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-fixed-top">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="index.html">Mammut</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li class="hidden">
                        <a href="#page-top"></a>
                    </li>
                    <li class="page-scroll">
                        <a href="manual.html">Tutorials</a>
                    </li>
                    <li class="page-scroll">
                        <a href="install.html">Install</a>
                    </li>
                    <li class="page-scroll">
                        <a href="contact.html">Contact</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container-fluid -->
    </nav>


	<!-- Begin Body -->
	<div class="container" style="">
		<div class="row" style="position:relative; top:60px">
  			<div class="col-md-3" id="leftCol">
	      			<ul class="nav nav-stacked navbar" id="sidebar">
	  				<li><a href="#intro">Introduction</a></li>
	  					<ul style="font-size:">
	  						<li style="text-transform: capitalize;"><a href="#introlocal">Local management</a></li>
	  						<li style="text-transform: capitalize;"><a href="#introremote">Remote management</a></li>
	  					</ul>
					<li><a href="#topology">Topology</a></li>
						<ul>
							<li style="text-transform: capitalize;"><a href="#topologytree">Topology analysis</a></li>
		                			<li style="text-transform: capitalize;"><a href="#topologyoff">Turning off cores</a></li>
		                			<li style="text-transform: capitalize;"><a href="#topologyidle">Idle states</a></li>
		                		</ul>
	  				<li><a href="#energy">Energy</a></li>
	  					<ul>
	  						<li style="text-transform: capitalize;"><a href="#energyread">Read energy</a></li>
	  						<li style="text-transform: capitalize;"><a href="#energytypes">Counters types</a></li>
	  						<li style="text-transform: capitalize;"><a href="#energycpu">CPU counters</a></li>
	  					</ul>
	  				<li><a href="#clockfrequency">Clock frequency</a></li>
						<ul>
	  						<li style="text-transform: capitalize;"><a href="#clockfrequencygovernors">Change governor</a></li>
	  						<li style="text-transform: capitalize;"><a href="#clockfrequencyfreq">Change frequency</a></li>
	  						<li style="text-transform: capitalize;"><a href="#clockfrequencyothers">Others</a></li>
	  					</ul>
	  				<li><a href="#tasks">Threads and processes</a></li>
	  					<ul>
	  						<li style="text-transform: capitalize;"><a href="#taskspin">Pinning</a></li>
	  						<li style="text-transform: capitalize;"><a href="#taskspriority">Change priority</a></li>
	  						<li style="text-transform: capitalize;"><a href="#tasksusage">CPU usage</a></li>
	  					</ul>
	      			</ul>
      			</div>  
      			<div class="col-md-9" style="position:relative; top:30px">
      				<!-------------------->
      				<!-- Introduction   -->
      				<!-------------------->
              			<h2 id="intro">Introduction</h2>
              			<p>
                			Mammut is structured as a set of <i>modules</i>, each of them managing a specific set of functionalities.
                			In this page you will find instructions and tutorials on how to use the library.
                			The tutorials can also be found in the corrisponding folder on the 
                			<a href="https://github.com/DanieleDeSensi/mammut/blob/master/demo/" target="_blank">GitHub repository.</a><br/>
                		</p>
                		<h3 id="introlocal">Local management</h3>
				<p>The following code snippet shows how to initialise the library:</p>
				<pre class="prettyprint">
					
#include &lt;mammut/mammut.hpp&gt;
using namespace mammut;
int main(int argc, char** argv){
    Mammut m;
}
				</pre>
				
				<h3 id="introremote">Remote management</h3>
				<p>
                			If you need to monitor a machine different from the one on which the
                			code is running, you simply need to specify the address of that machine,
                			as in the following snippet:
        			</p>
				<pre class="prettyprint">
					
Mammut m(new CommunicatorTcp(remoteMachineAddress, remoteMachinePort));
				</pre>
                		<p>
                			In this case, a <a href="server.html">Mammut server</a> should run on the 
                			remote machine. Please notice that this is the only modification required
                			if you need to monitor a machine different from the local one. 
                			Once you instantiated Mammut, you can require handlers to the different
                			modules. In the following we will describe each module separately, showing
                			the main features provided and how to use them.
              			</p>
              			

				<!---------------------->
				<!-- Topology section -->
				<!---------------------->
				<hr class="col-md-12">
              			<h2 id="topology">Topology</h2>
		              	<p>
		                The topology module allows to analyse the topology of the machine. It mainly
		                provides the following features:
		                	<ul>
		                		<li>Analysis of the relationship between virtual cores, physical cores and CPUs.</li>
		                		<li>Turn on/off of cores.</li>
		                		<li>Management of the idle states (C-states).</li>
		                	</ul>
		               	<br>
				</p>
				<p>
		                The following terminology will be coherently used in documentation/function names.
		                	<ul>
 					<li><b>CPU</b>: A system is composed by one or more CPU. Each of them is composed by one or more physical core.</li>
 					<li><b>Physical Core</b>: The basic computation unit of the CPU.</li>
 					<li><b>Virtual core</b>: When HyperThreading is present, more virtual cores (contextes) will be present on each
 					    physical core.</li>
 					</ul>
		                </p>
		                <h3 id="topologytree">Topology analysis</h3>
		                <p>
		               	The following code snippet shows how to get the list of CPUs, physical cores
		               	and virtual cores present on the machine:
		               	</p>
		               	
				<pre class="prettyprint">
					
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::topology;
using namespace std;
int main(int argc, char** argv){
    Mammut m;
    Topology* topology = m.getInstanceTopology();
    
    vector<Cpu*> cpus = topology->getCpus();
    vector<PhysicalCores*> physicalCores = topology->getPhysicalCores();
    vector<VirtualCores*> virtualCores = topology->getVirtualCores();
}
				</pre>
						<p>You can also analyse these relationships at a finer grained level. For
						example, to only get the virtual cores on CPU 1, you can do:</p>
				<pre class="prettyprint">
					
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::topology;
using namespace std;
int main(int argc, char** argv){
    Mammut m;
    Topology* topology = m.getInstanceTopology();
    Cpu* cpuOne = topology->getCpu(1);
    vector<VirtualCores*> virtualCores = cpuOne->getVirtualCores();
}
				</pre>  
						<p>Similarly, you can retrieve the virtual cores associated to a physical 
						core, the physical cores associated to a CPU and so on. You can also
						retrieve their identifiers, as assigned by the Operating System.
						Moreover, you can check which flags are present on your CPUs (e.g. 
						<code>sse</code>, <code>avx</code>, etc...). You can find
						all the available member functions on the <a href="doxygen.html">Doxygen</a>
						documentation</p>
		                
		                <h3 id="topologyonoff">Turning off cores</h3>
		                <p>
		                Once you have a <code>VirtualCore</code> object, you can 
		                <a target="_blank" href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">turn off</a> 
		                the corresponding virtual core, if such possibility is provided.
		                The following code snippet shows how to turn off and then turn
		                on again the virtual core with id 2. 
		                </p>
				<pre class="prettyprint">
					
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::topology;
using namespace std;
int main(int argc, char** argv){
    Mammut m;
    Topology* topology = m.getInstanceTopology();
    VirtualCore* core = topology->getVirtualCore(2);
    if(!core){
        cout << "Core not present." << endl;
    }
    if(core->isHotPluggable()){
        core->hotUnplug();
        if(core->isHotPlugged()){
            cout << "Failed to offline the core." << endl;
        }else{
            cout << "Core offlined." << endl;
        }
        core->hotPlug();
        cout << "Core online again." << endl;
    }else{
        cout << "Core cannot be offlined." << endl;
    }
}
				</pre>  
				
				<div class="alert alert-block alert-danger">
     					<h4 class="alert-heading">Attention!</h4>
     					Put cores offline may require running
		                      	the application with <code>sudo</code> rights.
     				</div>
		                
		                <h3 id="topologyidle">Idle states</h3>
		                <p>The topology module also provides the possibility to analyse
		                and modify the cores idle states. The following code snippet
		                shows a full working example about the idle states management
		                for the <i>virtual core</i> with identifier 0:</p>
				<pre class="prettyprint">

#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::topology;
using namespace std;

int main(int argc, char** argv){
    Mammut mammut;
    VirtualCore* vc = mammut.getInstanceTopology()->getVirtualCore(0);
    vector<VirtualCoreIdleLevel*> idleLevels = vc->getIdleLevels();
    if(idleLevels.size() == 0){
        cout << "No idle levels supported by Virtual Core 0." << endl;
    }else{
        cout << "The following idle levels are supported by Virtual Core 0:" << endl;
        for(size_t i = 0; i < idleLevels.size(); i++){
            VirtualCoreIdleLevel* level = idleLevels.at(i);
            cout << "[Idle Level: " << level->getLevelId() << "]";
            cout << "[Name: " << level->getName() << "]";
            cout << "[Desc: " << level->getDesc() << "]";
            cout << "[Consumed Power: " << level->getConsumedPower() << "]";
            cout << "[Exit latency: " << level->getExitLatency() << "]";
            cout << "[Absolute Time: " << level->getAbsoluteTime() << "]";
            cout << "[Absolute Count: " << level->getAbsoluteCount() << "]";
            cout << "[Enableable: " << level->isEnableable() << "]";
            cout << "[Enabled: " << level->isEnabled() << "]";
            cout << endl;
        }
    }
}
				</pre> 
				<p>
				If you need, you can disable and then enable agian
				a specific idle level in the following way:
				</p>
				<pre class="prettyprint">
					
if(level->isEnableable() && level->isEnabled()){
    level->disable();
    // Do stuff
    level->enable();
}
				</pre> 
				
				<div class="alert alert-block alert-danger">
     					<h4 class="alert-heading">Attention!</h4>
     					Disabling idle states may require running
		                      	the application with <code>sudo</code> rights.
     				</div>
				
				<!-------------------->
				<!-- Energy section -->
				<!-------------------->
				<hr class="col-md-12">
              			<h2 id="energy">Energy</h2>
		              	<p>
		                The energy module allows to read the energy consumption of the machine. This
		                feature is currently supported on the following architectures:
		                </p>
		                <ul>
		                	<li><b>Intel SandyBridge, IvyBridge and Haswell</b>. For these architectures, 
		                	    it is possible to read energy consumption of each CPU, of the cores on the CPU,
		                	    of the DRAM controller and of the integrated graphic card. On some of these 
		                	    machines DRAM or integrated graphic counters may not be available. To use the 
		                	    energy counters, the msr module must be loaded. A <code>sudo modprobe msr</code> 
		                	    should be enough to let it work.</li>
							<li><a href="http://www.hardkernel.com/main/main.php" target="_blank">
							    Odroid</a> machines. For these architectures, it is possible to read the total energy 
							    consumption if a 
							    <a href="http://odroid.com/dokuwiki/doku.php?id=en:odroidsmartpower" target="_blank">SmartPower</a>
							    is connected to the machine.</li>
							<li><b>Other machines</b> with a power supply voltage between <b>3.0V and 5.25V</b>. 
							    For these machines, it is possible to read the total energy consumption if a 
							    SmartPower is connected to the machine, similarly to the previous point.</li>
		                </ul>
		                <h3 id="energyread">Read energy</h3>
		                <p>
		               	The following code snippet shows how to read energy consumption. 
		              	</p>
		              	<pre id="#joules" class="prettyprint linenums">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::energy;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    Energy* energy = m.getInstanceEnergy();
    Joules j;

    Counter* counter = energy->getCounter();
    if(!counter){
        cout << "Power counters not available on this machine." << endl;
        return -1;
    }

    counter->reset();
    sleep(2);
    j = counter->getJoules();
    cout << j << " joules consumed in the last 2 seconds." << endl;

    counter->reset();
    sleep(4);
    j = counter->getJoules();
    cout << j << " joules consumed in the last 4 seconds." << endl;
}
				</pre>
				<p>First of all, an handler to the energy module is obtained (line 13). Then,  
				we require an energy counter (line 16). After that, we measure a code section
				(lines 22-24). Eventually, we reset the energy counter and we measure another
				code section (lines 27-29).
				</p>
				
				<div class="alert alert-block alert-danger">
     					<h4 class="alert-heading">Attention!</h4>
     					Reading the energy consumption may require running
		                      	the application with <code>sudo</code> rights.
     				</div>
     				
				<div class="alert alert-block alert-danger">
     					<h4 class="alert-heading">Attention!</h4>
					On Intel architectures, the <code>msr</code> kernel
					module needs to be loaded.
     				</div>

				<h3 id="energytypes">Counter types</h3>
				<p>
				Different type of energy counters are supported by Mammut.
				<ul>
					<li><b>Plug</b> counters: They count the power consumption
					of the entire machine, as seen at the power plug level.</li>
					
					<li><b>CPU</b> conters: They count the power consumption
					of the CPUs and of individual components of the CPU.</li>
				</ul>
				<br/>
				</p>
				<p>
				To check the types of available counters, just call 
				<code>getCountersTypes()</code> on the <code>Energy</code>
				object. This call will return a vector of avaiable counters
				types.
				<br/>
				By default, the <code>getCounter()</code> call will return the most
				fine grained counter among those available. For example, if both 
				<b>Plug</b> and <b>CPU</b> counters are availble, the <code>getCounter()</code>
				call will return the <b>CPU</b> counter.
				<br/>
				It is also possible to explicitly require a specific counter type. To do 
				that, you just need to specify the type of the counter. E.g., to get
				a <b>Plug</b> energy counter, you just need to replace the 
				<code>getCounter()</code> call with a <code>getCounter(COUNTER_PLUG)</code>
				call. If a specific type of counter is not available on the monitored machine,
				the call will return a NULL value.
				</p>
				
				<h3 id="energycpu">CPU counters</h3>
				<p>
				If CPU counters are available (this possibility is usually available on newer Intel
				machines), then it is possible to monitor the energy consumption of each CPU on the
				machine, of the set of cores on each CPU, of the uncore components of each CPU
				(e.g. integrated graphic card) or of the DRAMs. 
				Depending on the specific type of architecture, some of these subcounters
				may not be available. The following code snippet shows how to check for the availability
				of these subcounters and how to read their energy consumption:
				</p>
		              	<pre class="prettyprint">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::energy;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    Energy* energy = m.getInstanceEnergy();

    /** Gets the energy counters (one per CPU). **/
    CounterCpus* counterCpus = (CounterCpus*) energy->getCounter(COUNTER_CPUS);
    if(!counterCpus){
        cout << "Cpu counters not present on this machine." << endl;
        return -1;
    }

    cout << "Sleeping 10 seconds." << endl;    
    sleep(10);

    cout << "Total Cpus Joules: " << counterCpus->getJoulesCpuAll() << " ";
    cout << "Total Cores Joules: " << counterCpus->getJoulesCoresAll() << " ";
    if(counterCpus->hasJoulesDram()){
        cout << "Total Dram Joules: " << counterCpus->getJoulesDramAll() << " ";
    }
    if(counterCpus->hasJoulesGraphic()){
        cout << "Total Graphic Joules: " << counterCpus->getJoulesGraphicAll() << " ";
    }
    cout << endl;
}
				</pre>
				<p>
				If you want to read the energy consumption of the components of a <b>specific</b>
				CPU, just replace the <code>getJoules*All()</code> calls
				with <code>getJoules*(cpuId)</code> calls. For example, to get the energy
				consumption of the cores on the CPU with id 1, just call
				<code>getJoulesCores(1)</code>. To further explore the relationship
				between the CPU id and the cores on that CPU, please read the manual
				for the <a href="#topology">topology module</a>.
				</p>
				
				<!----------------------------->
				<!-- Clock frequency section -->
				<!----------------------------->
				<hr class="col-md-12">
              			<h2 id="clockfrequency">Clock frequency</h2>
              			<p>
              			This module provides the possibility to check the current frequency governor
              			and the current frequency and to modify them. Usually, is not possible to change
              			the frequency of the cores individually but only to change a frequency of 
              			a set of cores (typically all those on the same CPU). For this reason, Mammut
              			has the concept of <i>frequency domain</i>. The following code snippet
              			shows how to retrieve the frequency domains available on the monitored
              			machine and the <a href="#topology">virtual cores</a> associated to each domain:
              			</p>
		              	<pre class="prettyprint">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::cpufreq;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    CpuFreq* frequency = m.getInstanceCpuFreq();

    vector<Domain*> domains = frequency->getDomains();
    cout << domains.size() << " frequency domains found" << endl;

    for(size_t i = 0; i < domains.size(); i++){
        Domain* domain = domains.at(i);
        vector<VirtualCore*> virtualCores = domain->getVirtualCores();
        cout << "Virtual cores on domain: " << domain->getId() << ":";
        for(size_t j = 0; j < virtualCores.size() ; j++){
            cout << virtualCores.at(j)->getVirtualCoreId();
        }
        cout << endl;
    }
}

				</pre>
				<h3 id="clockfrequencygovernors">Change governor</h3>
				<p>
				Once you have a frequency domain, you can change its governor. A governor
				is a specific algorithm that regulates the frequency management. More information
				about governors can be found <a href="https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt">here</a>.
				You can get a list of governors available on the monitored machine by using a
				<code>getAvailableGovernors()</code> call on the domain object. 
				The current used governor on the domain can be retrieved by calling
				the <code>getCurrentGovernor()</code> call. 
				To set a specific governor (e.g. <i>userspace</i>), you can use the  
				<code>setGovernor(GOVERNOR_USERSPACE)</code> call.
				</p>
				
				<div class="alert alert-block alert-danger">
     					<h4 class="alert-heading">Attention!</h4>
					To use the <code>userspace</code> governor,
					the <code>acpi-cpufreq</code> driver must be loaded.
     				</div>
				
				<h3 id="clockfrequencyfreq">Change frequency</h3>
				<p>
				If the current governor of the domain is <i>userspace</i>, then you can set the domain
				to a specific frequency by using the <code>setFrequencyUserspace(f)</code> call.
				By using the <code>getAvailableFrequencies()</code> member function you can
				get the list of the frequencies available on the machine (sorted from the lowest
				to the highest).
				The following code shows how to set all the domains to the lowest frequency:
				</p>
		              	<pre class="prettyprint">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::cpufreq;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    CpuFreq* frequency = m.getInstanceCpuFreq();
    vector<Domain*> domains = frequency->getDomains();
    for(size_t i = 0; i < domains.size(); i++){
        Domain* domain = domains.at(i);
        vector<Frequency> frequencies = domain->getAvailableFrequencies();

        /** Set the domain to the lowest frequency. **/
        if(domain->isGovernorAvailable(GOVERNOR_USERSPACE) && frequencies.size()){
            Frequency target = frequencies.at(0);
            cout << "Setting domain " << domain->getId() << " to frequency " << target << endl;
            domain->setGovernor(GOVERNOR_USERSPACE);
            domain->setFrequencyUserspace(target);
        }
    }
}

				</pre>
              			
				<h3 id="clockfrequencyothers">Others</h3>
				<p>
					Other calls are available, for example to get the current voltage
					of the domain, or to get the latency required to change the frequency.
					You can find the full list on the <a href="doxygen.html">Doxygen</a>
					documentation.
				</p>
				
				<!------------------->
				<!-- Tasks section -->
				<!------------------->
				<hr class="col-md-12">
              			<h2 id="tasks">Threads and processes management</h2>
              			<p>
              				This module allows to manage the threads and processes
              				currently running on the machine. An handler is associated to each
              				process or thread. To get a process handler you should use the
              				<code>getProcessHandler(pid)</code> call on the module. 
              				This handler must be explicitly released with the 
              				<code>releaseProcessHandler()</code> call.
              				To get a thread handler, you should call the <code>getThreadHandler(tid)</code>
					on the <code>ProcessHandler</code> object. This handler must be released
					as well when not needed.
              				For example, by using the following code you can get an handler to the
              				thread with identifier 9999 in the process with process identifier 9900:
              			</p>
		              	<pre class="prettyprint">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::task;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    TasksManager* pm = m.getInstanceTask();
    
    ProcessHandler* process = pm->getProcessHandler(9900);
    ThreadHandler* thread = process->getThreadHandler(9999);
    // Do something with the handler.
    process->releaseThreadHandler(thread);
    pm->releaseProcessHandler(process);
    return 0;
}

				</pre>
				<p>
				<div class="alert alert-block alert-danger">
     					<h4 class="alert-heading">Attention!</h4>
     					Managing processes and threads started by an used
     					different from the one that is using the application
     					may require running
		                      	the application with <code>sudo</code> rights.
     				</div>
				</p>
              			
				<h3 id="taskspin">Pinning</h3>
				<p>
					Once you have an handler to a thread (or process),
					you can force it to run on a specific CPU, physical
					core or on a specific set of virtual cores, as shown
					in the following example:
				</p>
		              	<pre class="prettyprint">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::task;
using namespace mammut::topology;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    TasksManager* pm = m.getInstanceTask();
    Topology* topology = m.getInstanceTopology();
    
    ProcessHandler* process = pm->getProcessHandler(9900);
    ThreadHandler* thread = process->getThreadHandler(9999);
    
    // Allows the thread to run on any core on CPU 0
    Cpu* cpu = topology->getCpu(0);
    if(cpu){
        thread->move(cpu);
    }
    
    // Allows the thread to run on the physical core with id 2
    PhysicalCore* pCore = topology->getPhysicalCore(2);
    if(pCore){
        thread->move(pCore);
    }
    
    // Allows the thread to run on the virtual cores with id 0 and 3
    vector<const VirtualCore*> vCores;
    VirtualCore* vCore = topology->getVirtualCore(0);
    if(vCore){
        vCores.push_back(vCore);
    }
    vCore = topology->getVirtualCore(3);
    if(vCore){
        vCores.push_back(vCore);
    }
    thread->move(vCores);
    
    process->releaseThreadHandler(thread);
    pm->releaseProcessHandler(process);
    return 0;
}
		
				</pre>
				<p>Please notice that the <code>move</code> call (as well as the other
				calls on process and thread handlers), may return false if the process
				or the thread does not exist anymore.</p>
				
				<h3 id="taskspriority">Change priority</h3>
				<p>
					Another feature provided by Mammut is the possibility
					to read and set the priority of a process or of a thread,
					by using the <code>getPriority</code> and 
					<code>setPriority</code> calls on the thread or process
					handler. The values are platform dependent and are included in the 
					range <code>[MAMMUT_PROCESS_PRIORITY_MIN, MAMMUT_PROCESS_PRIORITY_MAX]</code>.
					Higher values represent higher priorities. The following
					code shows how to set a thread to the higher priority:
				</p>
		              	<pre class="prettyprint">
#include &lt;mammut/mammut.hpp&gt;

#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace mammut;
using namespace mammut::task;
using namespace mammut::topology;
using namespace std;

int main(int argc, char** argv){
    Mammut m;
    TasksManager* pm = m.getInstanceTask();
    Topology* topology = m.getInstanceTopology();
    
    ProcessHandler* process = pm->getProcessHandler(9900);
    ThreadHandler* thread = process->getThreadHandler(9999);
    
    thread->setPriority(MAMMUT_PROCESS_PRIORITY_MAX);    

    process->releaseThreadHandler(thread);
    pm->releaseProcessHandler(process);
    return 0;
}
		
				</pre>
				<h3 id="tasksusage">CPU usage</h3>
				<p>
					By using Mammut, you can also check what is the percentage of time
					that a process or a thread spent running on the CPU.
					You can do that by using the <code>getCoreUsage</code>
					call on the thread or process handler. You can reset that 
					percentage by using the	<code>resetCoreUsage</code> call.
				</p>
              			
				<!--
		              	<div class="row">
		                  <div class="col-md-6">
		                    <div class="panel panel-default">
		                      <div class="panel-heading"><h3>Warning</h3></div>
		                      <div class="panel-body">				
     					Reading the energy consumption may require running
		                      	the application with <code>sudo</code> rights.
		                      </div>
		                    </div>
		                  </div>
		                  <div class="col-md-6">
		                      <div class="panel panel-default">
		                      <div class="panel-heading"><h3>Warning</h3></div>
		                      <div class="panel-body">On Intel architectures, the <code>msr</code> kernel
		                      module needs to be loaded.
		                      </div>
		                    </div>
		                  </div>  
		              	</div>
		              
		              	<hr>
		              
		              	<h2 id="sec2">Section 2</h2>
		              	<p>
		                Rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae 
		                dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia cor magni dolores 
		                eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, 
		                sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. 
		                Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut!
		              	</p>
		              	<div class="row">
		              		<div class="col-md-4"><img src="//placehold.it/300x300" class="img-responsive"></div>
		                  	<div class="col-md-4"><img src="//placehold.it/300x300" class="img-responsive"></div>
		                  	<div class="col-md-4"><img src="//placehold.it/300x300" class="img-responsive"></div>
		              	</div>
		              
		              	<hr>
		              
		              	<h2 id="sec3">Section 3</h2>
		      			Images are responsive sed @mdo but sum are more fun peratis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, 
		                totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae 
		                dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia cor magni dolores 
		                eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, 
		                sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. 
		                Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut..
		              	<br>
		                Fos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, 
		                sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. 
		                Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut..
		              
		              
		              	<h2 id="sec4">Section 4</h2>
		      			Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, 
		                totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae 
		                dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia cor magni dolores 
		                eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, 
		                sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. 
		                Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut
		      		</div> 
		      		-->
		  	</div>
		</div>



	<!-- script references -->
	    <!-- jQuery -->
	    <script src="js/jquery.js"></script>
	
	    <!-- Bootstrap Core JavaScript -->
	    <script src="js/bootstrap.min.js"></script>
	
	    <!-- Plugin JavaScript -->
	    <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.3/jquery.easing.min.js"></script>
	    <script src="js/classie.js"></script>
	    <script src="js/cbpAnimatedHeader.js"></script>
	
	    <!-- Contact Form JavaScript -->
	    <script src="js/jqBootstrapValidation.js"></script>
	
	    <!-- Custom Theme JavaScript -->
	    <script src="js/freelancer.js"></script>
	    <script src="js/barscripts.js"></script>
	    
	    <script type="text/javascript">
	        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	    </script>
	    <script type="text/javascript">
	        try {
	            var pageTracker = _gat._getTracker("UA-74455716-1");
	            pageTracker._trackPageview();
	        } catch(err) {}
	    </script>
	    
	    <script type="text/javascript">
	        $( window ).load(function() {   
	            boxes = $('.col-sm-4');
	            maxHeight = Math.max.apply(
	            Math, boxes.map(function() {
	            return $(this).height();
	            }).get());
	            boxes.height(maxHeight);
	            $('.col-sm-12 .panel').height(maxHeight/2-22);//22 = 20 (bottom-margin) + 2 *1 (border)
	        });
	        
	        
	        ! function ($) {
	        	$(function () {
	            		window.prettyPrint && prettyPrint()
	        	})
    		}(window.jQuery)
	    </script>
	</body>
</html>
